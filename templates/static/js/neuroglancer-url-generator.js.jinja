{% raw -%}
 /**
 * Neuroglancer URL Generator
 *
 * This module provides functionality to generate Neuroglancer URLs dynamically
 * on the client side, replacing server-side template generation.
 * The template is embedded directly for file:// URL compatibility.
 */
{%- endraw %}

// Embedded neuroglancer template - complete configuration as JavaScript object
const NEUROGLANCER_TEMPLATE = {{ neuroglancer_json | safe }};

// Dataset information for conditional behavior
const DATASET_NAME = "{{ dataset_name }}";
const IS_FAFB_DATASET = DATASET_NAME.toLowerCase().includes("fafb");

// Neuroglancer base URL from configuration
const NEUROGLANCER_BASE_URL = "{{ neuroglancer_base_url }}";

// ROI data loaded dynamically from Google Cloud Storage
const ROI_IDS = {{ roi_ids|tojson }};
const ALL_ROIS = {{ all_rois|tojson }};
const VNC_IDS = {{ vnc_ids|tojson }};
const VNC_NAMES = {{ vnc_names|tojson }};

// ROI context tracking to fix ID collision issues
// Stores ROI IDs with their source context (brain vs vnc)
const selectedRoiContexts = new Map(); // id -> {source: 'brain'|'vnc', name: string}

{% raw %}

/* ────────────────────────────────────────────────────────────────────────── */
/* Background colour                                                          */
/* ────────────────────────────────────────────────────────────────────────── */

// Theme → NG projection background color
const BG_BY_THEME = { dark: "#1a1a1a", light: "#ffffff" };
let currentNgTheme = "dark";
let currentProjectionBg = BG_BY_THEME[currentNgTheme];

/* ────────────────────────────────────────────────────────────────────────── */
/* Connectivity partners: click-to-toggle bodyIds per type                    */
/* ──────────────────────────────────────────────────────────────────────────


 * Wire click-to-toggle for upstream/downstream partner types in the connectivity tables.
 * Toggle rule:
 *  - If *all* bodyIds for the clicked type are already selected => remove them (OFF).
 *  - Otherwise => add them all (ON).
 * @param {{
 *   websiteTitle: string,
 *   visibleNeurons?: (string|number)[],
 *   neuronQuery?: string,
 *   visibleRois?: string[]
 * }}
 */

// Robust JSON.parse for data-body-ids
const safeParseIds = (s) => {
  try {
    const v = JSON.parse(s || "[]");
    return Array.isArray(v) ? v : []; // coalesce "null" → []
  } catch {
    return [];
  }
};

/**
 * Get all body IDs that come from connectivity partners
 * @returns {Set<string>} Set of all body IDs from partner cells
 */
function getAllConnectivityBodyIds() {
  const connectivityBodyIds = new Set();
  document.querySelectorAll("td.p-c").forEach((td) => {
    const bodyIds = safeParseIds(td.dataset.bodyIds);
    bodyIds.forEach((id) => connectivityBodyIds.add(String(id)));
  });
  return connectivityBodyIds;
}

/**
 * Check if any connectivity body IDs are currently active in visibleNeurons
 * @param {string[]} visibleNeurons - Array of currently visible neuron IDs
 * @returns {boolean} True if any connectivity body IDs are active
 */
function hasActiveConnectivityBodies(visibleNeurons) {
  const connectivityBodyIds = getAllConnectivityBodyIds();
  const visibleSet = new Set((visibleNeurons || []).map(String));

  console.log(
    "[CONNECTIVITY CHECK] connectivityBodyIds:",
    Array.from(connectivityBodyIds),
    "visibleNeurons:",
    visibleNeurons,
  );

  for (const bodyId of connectivityBodyIds) {
    if (visibleSet.has(bodyId)) {
      console.log(
        "[CONNECTIVITY ACTIVE] Found active connectivity body:",
        bodyId,
      );
      return true;
    }
  }
  return false;
}

function syncConnectivityCheckboxes(pageData, limitToDirection = null) {
  const pd = pageData;
  const selected = new Set((pd.visibleNeurons || []).map(String));
  // define tableSelector safely
  const tableSelector = limitToDirection
    ? limitToDirection === "upstream"
      ? "#upstream-table"
      : "#downstream-table"
    : "";

  const cellSelector = limitToDirection ? `${tableSelector} td.p-c` : "td.p-c";

  document.querySelectorAll(cellSelector).forEach((td) => {
    // Get connected bodyIds from table
    const bodyIds = safeParseIds(td.dataset.bodyIds);

    // Check if bodyIds is empty
    const hasNoBodyIds = bodyIds.length === 0;

    // Determine if all body IDs are currently selected
    const allOn =
      bodyIds.length > 0 && bodyIds.every((id) => selected.has(String(id)));

    // Create or update checkbox
    let checkbox = td.querySelector("input[type='checkbox']");
    if (!checkbox) {
      checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "";
      const plural = bodyIds.length > 1 ? "s" : "";
      checkbox.title = `Toggle neuron ${plural} ${bodyIds.join(" and ")} in neuron visualization (above)`;
      checkbox.setAttribute("aria-label", `Toggle partner`);

      // Create label wrapper
      const label = document.createElement("label");
      label.className = "p-c-label";

      // Move existing content to label and add checkbox before
      const existingContent = td.innerHTML;
      label.innerHTML = existingContent;
      td.innerHTML = "";
      td.appendChild(checkbox);
      td.appendChild(label);
    }

    // Check if we should disable this checkbox based on partner type and current neuron
    const partnerType = td.dataset.partnerType;
    const currentNeuronType = pd.currentNeuronType;
    const shouldDisable = partnerType && currentNeuronType &&
                         partnerType === currentNeuronType &&
                         bodyIds.some(id => (pd.visibleNeurons || []).includes(id) || (pd.visibleNeurons || []).includes(String(id)));

    // Handle empty body IDs case or self-reference case
    if (hasNoBodyIds || shouldDisable) {
      if (hasNoBodyIds) {
        console.log("[CHECKBOX] Empty body IDs detected for partner cell:", td);
        td.classList.add("no-body-ids");
      }
      if (shouldDisable) {
        console.log("[CHECKBOX] Disabling checkbox for self-reference:", partnerType, "matches current neuron type:", currentNeuronType, "with visible bodyIds:", bodyIds);
        td.classList.add("self-reference");
      }
      checkbox.disabled = true;
      checkbox.checked = false;
      td.classList.remove("partner-on");
    } else {
      checkbox.disabled = false;
      td.classList.remove("no-body-ids", "self-reference");
      // Update checkbox state
      checkbox.checked = allOn;
      // Apply styling to the wrapper
      td.classList.toggle("partner-on", allOn);
    }
  });
}

function wireConnectivityCheckboxes(pageData) {
  const pd = pageData;

  // Handle user toggles using event delegation
  document.addEventListener("change", (e) => {
    const checkbox = e.target;
    if (!(checkbox instanceof HTMLInputElement) || checkbox.type !== "checkbox")
      return;

    const td = checkbox.closest("td.p-c");
    if (!td) return;

    // Skip interaction if checkbox is disabled (no body IDs)
    if (checkbox.disabled) {
      checkbox.checked = false;
      return;
    }

    // Only this cell’s IDs (keep original number types if provided)
    const cellIds = safeParseIds(td.dataset.bodyIds);
    if (cellIds.length === 0) {
      checkbox.checked = false;
      return;
    }

    // Track user intent
    const intended = checkbox.checked;

    // Build a string Set for comparisons
    const selStrings = new Set((pd.visibleNeurons || []).map(String));

    // Keep a numeric array for storage (important for Neuroglancer)
    let current = Array.isArray(pd.visibleNeurons)
      ? pd.visibleNeurons.slice()
      : [];

    // Helpers to keep string/numeric views consistent
    const addId = (id) => {
      const s = String(id);
      if (!selStrings.has(s)) {
        selStrings.add(s);
        current.push(id); // store numeric
      }
    };
    const removeId = (id) => {
      const s = String(id);
      if (selStrings.has(s)) {
        selStrings.delete(s);
        const idx = current.findIndex((x) => String(x) === s);
        if (idx !== -1) current.splice(idx, 1);
      }
    };

    if (intended) {
      // ON: add only this cell's IDs
      cellIds.forEach(addId);
    } else {
      // OFF: remove this cell’s IDs unless another checked cell still selects them
      const otherSelected = new Set();
      document.querySelectorAll("td.p-c").forEach((otherTd) => {
        if (otherTd === td) return;
        const otherCb = otherTd.querySelector("input[type='checkbox']");
        if (otherCb && otherCb.checked && !otherCb.disabled) {
          const ids = safeParseIds(otherTd.dataset.bodyIds);
          ids.forEach((id) => otherSelected.add(String(id)));
        }
      });

      cellIds.forEach((id) => {
        if (!otherSelected.has(String(id))) removeId(id);
      });
    }

    // Store back numeric IDs (critical for Neuroglancer resolution)
    pd.visibleNeurons = current;

    // Style just this cell
    td.classList.toggle("partner-on", intended);

    const ngVisibleNeurons = Array.isArray(pd.visibleNeurons)
      ? pd.visibleNeurons
      : [];
    const ngVisibleRois = Array.isArray(pd.visibleRois) ? pd.visibleRois : [];
    const ngQuery = typeof pd.neuronQuery === "string" ? pd.neuronQuery : "";

    // Update Neuroglancer
    try {
      updateNeuroglancerLinks(
        pd.websiteTitle,
        pd.visibleNeurons, // numeric IDs
        pd.neuronQuery || "",
        pd.visibleRois || [],
        pd.region || "",
        typeof currentProjectionBg !== "undefined" ? currentProjectionBg : null,
      );
    } catch (err) {
      console.error("[NG] updateNeuroglancerLinks failed:", err);
    }
  });

  // Initial sync
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () =>
      syncConnectivityCheckboxes(pd),
    );
  } else {
    syncConnectivityCheckboxes(pd);
  }

  // Re-sync after DataTables redraws (run once)
  if (window.jQuery && jQuery.fn && jQuery.fn.dataTable) {
    jQuery("#upstream-table, #downstream-table").on("draw.dt", () =>
      syncConnectivityCheckboxes(pd),
    );
    jQuery("#roi-table").on("draw.dt", () => {
      if (typeof syncRoiCheckboxes === "function") syncRoiCheckboxes();
      setTimeout(() => {
        const roiTable = document.getElementById("roi-table");
        if (roiTable) {
          roiTable.style.tableLayout = "fixed";
          roiTable.querySelectorAll("tbody td:first-child").forEach((cell) => {
            cell.style.width = "250px";
            cell.style.maxWidth = "250px";
          });
        }
      }, 10);
    });
  }
}

/* ────────────────────────────────────────────────────────────────────────── */
/* ROI checkboxes: create checkboxes, sync state, handle toggles              */
/* ────────────────────────────────────────────────────────────────────────── */

/**
 * Creates checkboxes for ROI cells and syncs their state with selectedRoiIds
 * For FAFB datasets, skips checkbox creation since neuroglancer data is not reliable
 */
function syncRoiCheckboxes() {
  document.querySelectorAll("td.roi-cell").forEach((td) => {
    const roiName = td.dataset.roiName;
    if (!roiName) return;

    // Check if it's a brain ROI or VNC neuropil
    let roiId = roiNameToId(roiName);
    let isVnc = false;
    if (!roiId) {
      roiId = vncNameToId(roiName);
      isVnc = true;
    }
    if (!roiId) return;

    // Handle both single IDs and arrays of IDs for combined ROIs
    const roiIds = Array.isArray(roiId) ? roiId : [roiId];
    if (roiIds.length === 0) return;

    // Skip checkbox creation for FAFB datasets - neuroglancer data not reliable
    if (IS_FAFB_DATASET) {
      // Just apply width enforcement for consistent table layout
      td.style.width = "250px";
      td.style.maxWidth = "250px";
      return;
    }

    // Determine if this ROI is currently selected
    // For combined ROIs, check if ANY of the sided ROIs are selected
    const isSelected = roiIds.some(id => selectedRoiIds.has(id));

    // Create or update checkbox
    let checkbox = td.querySelector("input[type='checkbox']");
    if (!checkbox) {
      checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "";
      checkbox.setAttribute("aria-label", `Toggle ${roiName}`);

      // Create label wrapper
      const label = document.createElement("label");
      label.className = "roi-cell-label";

      // Move existing content to label and add checkbox before
      const existingContent = td.innerHTML;
      label.innerHTML = existingContent;
      td.innerHTML = "";
      td.appendChild(checkbox);
      td.appendChild(label);
    }

    // Update checkbox state
    checkbox.checked = isSelected;

    // Apply styling to the wrapper
    td.classList.toggle("roi-on", isSelected);

    // Simple width enforcement
    td.style.width = "250px";
    td.style.maxWidth = "250px";
  });
}

/**
 * Wire ROI checkbox event handlers
 * For FAFB datasets, this is a no-op since checkboxes are not created
 */
function wireRoiCheckboxes(pageData) {
  // Skip event handling for FAFB datasets since checkboxes don't exist
  if (IS_FAFB_DATASET) {
    return;
  }

  document.addEventListener("change", (e) => {
    const checkbox = e.target;
    if (!(checkbox instanceof HTMLInputElement)) return;
    if (checkbox.type !== "checkbox") return;
    if (!checkbox.closest("td.roi-cell")) return;

    const td = checkbox.closest("td.roi-cell");
    if (!td) return;

    const roiName = td.dataset.roiName;
    if (!roiName) {
      console.warn("[ROI CHECKBOX] Missing data-roi-name on element:", td);
      checkbox.checked = false;
      return;
    }

    // Check if it's a brain ROI or VNC neuropil
    let roiId = roiNameToId(roiName);
    let isVnc = false;
    if (!roiId) {
      roiId = vncNameToId(roiName);
      isVnc = true;
    }
    if (!roiId) {
      console.warn("[ROI CHECKBOX] ROI not found:", roiName);
      checkbox.checked = false;
      return;
    }

    // Handle both single IDs and arrays of IDs for combined ROIs
    const roiIds = Array.isArray(roiId) ? roiId : [roiId];
    if (roiIds.length === 0) {
      console.warn("[ROI CHECKBOX] No ROI IDs for:", roiName);
      return;
    }

    console.log(
      "[ROI CHECKBOX] name:",
      roiName,
      " -> ids:",
      roiIds,
      "isVnc:",
      isVnc,
      "checked:",
      checkbox.checked,
    );

    if (checkbox.checked) {
      // Add ROI IDs with proper context
      if (isVnc) {
        addVncRoiIds(roiIds, roiName);
      } else {
        addBrainRoiIds(roiIds, roiName);
      }
      console.log(
        "[ROI TOGGLE] added",
        roiIds,
        "source:",
        isVnc ? 'vnc' : 'brain',
        "current:",
        Array.from(selectedRoiIds),
      );
    } else {
      // Remove ROI IDs and clear context
      removeRoiIds(roiIds);
      console.log(
        "[ROI TOGGLE] removed",
        roiIds,
        "current:",
        Array.from(selectedRoiIds),
      );
    }

    td.classList.toggle("roi-on", checkbox.checked);

    // Update page data and neuroglancer
    pageData.visibleRois = Array.from(selectedRoiIds);
    console.log("[UPDATE] visibleRois:", pageData.visibleRois);

    updateNeuroglancerLinks(
      pageData.websiteTitle,
      pageData.visibleNeurons,
      pageData.neuronQuery,
      pageData.visibleRois,
      pageData.region,
      currentProjectionBg,
    );
  });
}

/* ────────────────────────────────────────────────────────────────────────── */
/* ROI clicking: map label → segment ID; toggle; style; update NG             */
/* ────────────────────────────────────────────────────────────────────────── */
// Make ROI shell visible when clicked on within the ROI table.
// ROI data is loaded dynamically from Google Cloud Storage (defined above)

if (ROI_IDS.length !== ALL_ROIS.length) {
  console.warn(
    "[ROI MAP] Length mismatch:",
    ROI_IDS.length,
    "ids vs",
    ALL_ROIS.length,
    "labels",
  );
}

if (VNC_IDS.length !== VNC_NAMES.length) {
  console.warn(
    "[VNC MAP] Length mismatch:",
    VNC_IDS.length,
    "ids vs",
    VNC_NAMES.length,
    "labels",
  );
}

const ROI_TO_ID = (() => {
  const map = Object.create(null);
  for (let i = 0; i < Math.min(ROI_IDS.length, ALL_ROIS.length); i++) {
    map[ALL_ROIS[i]] = String(ROI_IDS[i]); // ensure string
  }
  return map;
})();

const VNC_TO_ID = (() => {
  const map = Object.create(null);
  for (let i = 0; i < Math.min(VNC_IDS.length, VNC_NAMES.length); i++) {
    map[VNC_NAMES[i]] = String(VNC_IDS[i]); // ensure string
  }
  return map;
})();

/**
 * Find sided ROI IDs for a combined ROI name.
 * For example, "AME" -> ["1", "2"] (IDs for "AME(L)" and "AME(R)")
 *
 * @param {string} baseName - Base ROI name without side suffix (e.g., "AME", "LO")
 * @returns {string[]} Array of neuroglancer IDs for sided versions
 */
function findSidedRoiIds(baseName) {
  const sidedIds = [];

  // Try common side patterns
  const patterns = [
    `${baseName}(L)`,
    `${baseName}(R)`,
    `${baseName}_L`,
    `${baseName}_R`
  ];

  patterns.forEach(pattern => {
    const id = ROI_TO_ID[pattern];
    if (id) {
      sidedIds.push(id);
    }
  });

  return sidedIds;
}

/**
 * Find sided VNC IDs for a combined VNC name.
 * For example, "LegNp(T1)" -> ["4", "5"] (IDs for "LegNp(T1)(L)" and "LegNp(T1)(R)")
 *
 * @param {string} baseName - Base VNC name without side suffix
 * @returns {string[]} Array of neuroglancer IDs for sided versions
 */
function findSidedVncIds(baseName) {
  const sidedIds = [];

  // Try common VNC side patterns
  const patterns = [
    `${baseName}(L)`,
    `${baseName}(R)`,
    `${baseName}_L`,
    `${baseName}_R`
  ];

  patterns.forEach(pattern => {
    const id = VNC_TO_ID[pattern];
    if (id) {
      sidedIds.push(id);
    }
  });

  return sidedIds;
}

/**
 * Resolve an ROI label to its Neuroglancer segment ID (as a string).
 *
 * Looks up the label in the prebuilt ROI_TO_ID table. If the label is not found,
 * tries to find sided equivalents for combined ROI names (e.g., "AME" -> ["AME(L)", "AME(R)"]).
 * For combined ROIs, returns an array of IDs instead of a single ID.
 *
 * @param {string} roiName - ROI label, e.g., "AME(L)", "LO(R)", or "AME" (combined).
 * @returns {string|string[]|null} Segment ID as a string, array of IDs for combined ROIs, or `null` if unknown.
 */
function roiNameToId(roiName) {
  const key = String(roiName).trim();
  const mapped = ROI_TO_ID[key];
  if (mapped) return mapped;

  // Try to find sided equivalents for combined ROI names
  const sidedIds = findSidedRoiIds(key);
  if (sidedIds.length > 0) {
    console.log("[ROI MAP] Combined ROI", key, "mapped to sided IDs:", sidedIds);
    return sidedIds;
  }

  console.warn("[ROI MAP] Shell for ROI not found:", key);
  return null;
}

/**
 * Add ROI ID(s) to the selected set with brain context.
 * @param {string|string[]} roiId - Single ID or array of IDs
 * @param {string} roiName - Original ROI name for context
 */
function addBrainRoiIds(roiId, roiName) {
  const roiIds = Array.isArray(roiId) ? roiId : [roiId];
  roiIds.forEach(id => {
    selectedRoiIds.add(id);
    selectedRoiContexts.set(id, { source: 'brain', name: roiName });
  });
}

/**
 * Add ROI ID(s) to the selected set with VNC context.
 * @param {string|string[]} roiId - Single ID or array of IDs
 * @param {string} roiName - Original ROI name for context
 */
function addVncRoiIds(roiId, roiName) {
  const roiIds = Array.isArray(roiId) ? roiId : [roiId];
  roiIds.forEach(id => {
    selectedRoiIds.add(id);
    selectedRoiContexts.set(id, { source: 'vnc', name: roiName });
  });
}

/**
 * Remove ROI ID(s) from the selected set and clear context.
 * @param {string|string[]} roiId - Single ID or array of IDs
 */
function removeRoiIds(roiId) {
  const roiIds = Array.isArray(roiId) ? roiId : [roiId];
  roiIds.forEach(id => {
    selectedRoiIds.delete(id);
    selectedRoiContexts.delete(id);
  });
}

/**
 * Initialize ROI contexts for existing selected ROI IDs.
 * This ensures that ROI IDs loaded from pageData have proper source context.
 * @param {string[]} existingRoiIds - Array of existing ROI IDs
 */
function initializeRoiContexts(existingRoiIds) {
  if (!Array.isArray(existingRoiIds)) return;

  existingRoiIds.forEach(roiId => {
    // Skip if context already exists
    if (selectedRoiContexts.has(roiId)) return;

    // Try to find the ROI name and source by checking both datasets
    const roiIdNum = parseInt(roiId);
    let found = false;

    // Check brain ROIs first
    const brainIndex = ROI_IDS.indexOf(roiIdNum);
    if (brainIndex !== -1 && brainIndex < ALL_ROIS.length) {
      selectedRoiContexts.set(roiId, {
        source: 'brain',
        name: ALL_ROIS[brainIndex]
      });
      found = true;
    }

    // Check VNC ROIs if not found in brain ROIs
    if (!found) {
      const vncIndex = VNC_IDS.indexOf(roiIdNum);
      if (vncIndex !== -1 && vncIndex < VNC_NAMES.length) {
        selectedRoiContexts.set(roiId, {
          source: 'vnc',
          name: VNC_NAMES[vncIndex]
        });
        found = true;
      }
    }

    if (!found) {
      console.warn("[INIT ROI CONTEXT] Unknown ROI ID:", roiId);
    }
  });

  console.log("[INIT ROI CONTEXT] Initialized contexts for", existingRoiIds.length, "ROI IDs");
}

/**
 * Resolve a VNC neuropil label to its Neuroglancer segment ID (as a string).
 *
 * Looks up the label in the prebuilt VNC_TO_ID table. If the label is not found,
 * tries to find sided equivalents for combined VNC names.
 * For combined VNCs, returns an array of IDs instead of a single ID.
 *
 * @param {string} vncName - VNC neuropil label, e.g., "LegNp(T1)(L)" or "LegNp(T1)" (combined).
 * @returns {string|string[]|null} Segment ID as a string, array of IDs for combined VNCs, or `null` if unknown.
 */
function vncNameToId(vncName) {
  const key = String(vncName).trim();
  const mapped = VNC_TO_ID[key];
  if (mapped) return mapped;

  // Try to find sided equivalents for combined VNC names
  const sidedIds = findSidedVncIds(key);
  if (sidedIds.length > 0) {
    console.log("[VNC MAP] Combined VNC", key, "mapped to sided IDs:", sidedIds);
    return sidedIds;
  }

  console.warn("[VNC MAP] Shell for VNC not found:", key);
  return null;
}

/**
 * Recompute which ROI names should be red, given current pageData/selection.
 * @param {{ visibleRois?: string[] }} pageData
 */
function renderRoiLinkStyles(pageData) {
  const layerVisible =
    pageData.visibleRois &&
    pageData.visibleRois.length > 0 &&
    pageData.visibleRois.length < 96;

  // Update legacy roi-link elements if they exist
  document.querySelectorAll(".roi-link").forEach((el) => {
    const roiName = el.getAttribute("data-roi-name");
    if (!roiName) return;

    // Check if it's a brain ROI or VNC neuropil
    let roiId = roiNameToId(roiName);
    let isVnc = false;
    if (!roiId) {
      roiId = vncNameToId(roiName);
      isVnc = true;
    }
    if (!roiId) return;

    const isSelected = selectedRoiIds.has(roiId);
    const isShown = layerVisible && isSelected;

    el.classList.toggle("roi-on", isShown);
  });

  // Update roi-cell elements
  document.querySelectorAll("td.roi-cell").forEach((td) => {
    const roiName = td.dataset.roiName;
    if (!roiName) return;

    // Check if it's a brain ROI or VNC neuropil
    let roiId = roiNameToId(roiName);
    let isVnc = false;
    if (!roiId) {
      roiId = vncNameToId(roiName);
      isVnc = true;
    }
    if (!roiId) return;

    // Handle both single IDs and arrays of IDs for combined ROIs
    const roiIds = Array.isArray(roiId) ? roiId : [roiId];
    const isSelected = roiIds.some(id => selectedRoiIds.has(id));
    const isShown = layerVisible && isSelected;

    td.classList.toggle("roi-on", isShown);

    // Update checkbox if it exists
    const checkbox = td.querySelector("input[type='checkbox']");
    if (checkbox) {
      checkbox.checked = isSelected;
    }
  });
}

/** @type {Set<string>} Selected ROI segment IDs (as strings) used for toggling. */
const selectedRoiIds = new Set();

/**
 * Handle clicks on ROI links (class `.roi-link`, attribute `data-roi-name`).
 * Toggles ROI ID in selection, updates pageData.visibleRois, refreshes NG, and restyles.
 * This function is kept for backward compatibility with legacy roi-link elements.
 *
 * @param {Object} pageData - Neuroglancer params object (mutated in place).
 * @param {string} pageData.websiteTitle
 * @param {string[]} pageData.visibleNeurons
 * @param {string} pageData.neuronQuery
 * @param {string[]} pageData.visibleRois
 * @returns {void}
 */
function wireRoiClicks(pageData) {
  const table = document.getElementById("roi-table") || document;

  console.log("[wireRoiClicks] binding to:", table.id || "document");

  table.addEventListener("click", (e) => {
    const el = e.target.closest(".roi-link");
    if (!el) return;

    const roiName = el.getAttribute("data-roi-name");
    if (!roiName) {
      console.warn("[ROI CLICK] Missing data-roi-name on element:", el);
      return;
    }

    // Check if it's a brain ROI or VNC neuropil
    let roiId = roiNameToId(roiName);
    let isVnc = false;
    if (!roiId) {
      roiId = vncNameToId(roiName);
      isVnc = true;
    }
    console.log("[ROI CLICK] name:", roiName, " -> id:", roiId);

    // Handle both single IDs and arrays of IDs for combined ROIs
    const roiIds = Array.isArray(roiId) ? roiId : [roiId];
    const isCurrentlySelected = roiIds.some(id => selectedRoiIds.has(id));

    if (isCurrentlySelected) {
      // Remove all sided ROI IDs for combined ROIs
      removeRoiIds(roiIds);
      el.classList.remove("selected");
      console.log(
        "[ROI TOGGLE] removed",
        roiIds,
        "current:",
        Array.from(selectedRoiIds),
      );
    } else {
      // Add all sided ROI IDs for combined ROIs with proper context
      if (isVnc) {
        addVncRoiIds(roiIds, roiName);
      } else {
        addBrainRoiIds(roiIds, roiName);
      }
      el.classList.add("selected");
      console.log(
        "[ROI TOGGLE] added",
        roiIds,
        "current:",
        Array.from(selectedRoiIds),
      );
    }

    pageData.visibleRois = Array.from(selectedRoiIds);
    console.log("[UPDATE] visibleRois:", pageData.visibleRois);

    updateNeuroglancerLinks(
      pageData.websiteTitle,
      pageData.visibleNeurons,
      pageData.neuronQuery,
      pageData.visibleRois,
      pageData.region,
      currentProjectionBg,
    );
    renderRoiLinkStyles(pageData);
  });
}

/* ────────────────────────────────────────────────────────────────────────── */
/* Neuroglancer URL generation + DOM updates                                  */
/* ────────────────────────────────────────────────────────────────────────── */

/**
 * Generates a Neuroglancer URL based on the provided parameters
 *
 * @param {string} websiteTitle - The title for the neuroglancer session
 * @param {string[]} visibleNeurons - Array of neuron bodyIDs to display
 * @param {string} neuronQuery - Query string for neuron search
 * @param {string[]} visibleRois - List of numbers as strings representing visible ROIs
 * @param {string[]} region - Region the type belongs to. Used for setting NG view.
 * @param {string} projectionBg - Background color for projection
 * @returns {string} The complete Neuroglancer URL
 */
// Inside generateNeuroglancerUrl
function generateNeuroglancerUrl(
  websiteTitle,
  visibleNeurons = [],
  neuronQuery = "",
  visibleRois = [],
  region = "",
  projectionBg = currentProjectionBg,
) {
  try {
    const neuroglancerState = JSON.parse(JSON.stringify(NEUROGLANCER_TEMPLATE));
    neuroglancerState.title = websiteTitle;
    neuroglancerState.projectionBackgroundColor = projectionBg;

    // Check if this is FAFB dataset by looking for the flywire-fafb layer
    const isFAFB = neuroglancerState.layers.some(
      (l) => l.type === "segmentation" && l.name === "flywire-fafb:v783b"
    );

    // Choose NG view based on dataset type and region
    if (isFAFB) {
      // For FAFB dataset, preserve the original position, scale, and orientation from template
      // These values are already set in the template, so we don't need to modify them
    } else if (region === "VNC") {
      // VNC-specific settings for CNS dataset
      neuroglancerState.position = [49613.625, 31780.240234375, 76198.75];
      neuroglancerState.projectionOrientation = [
        0.7071970105171204, 0.0005355576286092401, 0.0005249528330750763,
        0.707016110420227,
      ];
      neuroglancerState.projectionScale = 134532.41491591922;
    } else {
      // Other CNS regions (non-VNC)
      neuroglancerState.position = [
        48850.046875, 31780.1796875, 26790.14453125,
      ];
      neuroglancerState.projectionOrientation = [];
      neuroglancerState.projectionScale = 74323.4144763075;
    }

    // Find the main segmentation layer (flexible for different datasets)
    const mainSegLayer = neuroglancerState.layers.find(
      (l) => l.type === "segmentation" && l.segments !== undefined &&
           (l.name === "cns-seg" || l.name === "flywire-fafb:v783b")
    );

    // Find the neuropil layers (flexible for different datasets)
    const neuropilLayer = neuroglancerState.layers.find(
      (l) => l.name === "brain-neuropils" || l.name === "neuropils"
    );
    const vncNeuropilLayer = neuroglancerState.layers.find(
      (l) => l.name === "vnc-neuropils"
    );

    // Add ROIs
    const rois = Array.isArray(visibleRois)
      ? visibleRois.map(String)
      : visibleRois
        ? [String(visibleRois)]
        : [];
    if (mainSegLayer) {
      mainSegLayer.segments = Array.isArray(visibleNeurons)
        ? visibleNeurons
        : [];

      // Clear segmentQuery if any connectivity body IDs are active
      const hasConnectivityBodies = hasActiveConnectivityBodies(visibleNeurons);
      console.log(
        "[SEGMENT QUERY] hasConnectivityBodies:",
        hasConnectivityBodies,
        "segmentQuery:",
        hasConnectivityBodies ? "CLEARED" : neuronQuery || "",
        "layerName:", mainSegLayer.name
      );
      mainSegLayer.segmentQuery = hasConnectivityBodies ? "" : neuronQuery || "";
    }
    if (neuropilLayer) {
      // Filter ROIs based on their source context to fix ID collision issues
      const brainRois = rois.filter(roiId => {
        const context = selectedRoiContexts.get(roiId);
        return context && context.source === 'brain';
      });

      neuropilLayer.segments = brainRois;
      neuropilLayer.visible = brainRois.length > 0;

      console.log("[LAYER ASSIGNMENT] brain-neuropils:", brainRois, "contexts:",
        brainRois.map(id => selectedRoiContexts.get(id)));
    }
    if (vncNeuropilLayer) {
      // Filter ROIs based on their source context to fix ID collision issues
      const vncRois = rois.filter(roiId => {
        const context = selectedRoiContexts.get(roiId);
        return context && context.source === 'vnc';
      });

      vncNeuropilLayer.segments = vncRois;
      vncNeuropilLayer.visible = vncRois.length > 0;

      console.log("[LAYER ASSIGNMENT] vnc-neuropils:", vncRois, "contexts:",
        vncRois.map(id => selectedRoiContexts.get(id)));
    }

    console.log(
      "[generateNeuroglancerUrl] rois:",
      rois,
      "visible:",
      neuropilLayer?.visible,
    );

    const encodedState = encodeURIComponent(JSON.stringify(neuroglancerState));
    return `${NEUROGLANCER_BASE_URL}/#!${encodedState}`;
  } catch (error) {
    console.error("Error generating neuroglancer URL:", error);
    throw error;
  }
}

/**
 * Updates neuroglancer links in the DOM with the provided parameters
 *
 * @param {string} websiteTitle - The title for the neuroglancer session
 * @param {string[]} visibleNeurons - Array of neuron bodyIDs to display
 * @param {string} neuronQuery - Query string for neuron search
 * @param {string[]} visibleRois - List of numbers as strings representing visible ROIs
 * @param {string[]} region - Region the type belongs to. Used for setting NG view.
 * @param {string} projectionBg - Background color for projection
 * @returns {void}
 */
function updateNeuroglancerLinks(
  websiteTitle,
  visibleNeurons = [],
  neuronQuery = "",
  visibleRois = [],
  region = "",
  projectionBg = currentProjectionBg,
) {
  try {
    const neuroglancerUrl = generateNeuroglancerUrl(
      websiteTitle,
      visibleNeurons,
      neuronQuery,
      visibleRois,
      region,
      projectionBg,
    );

    // Update all elements with class 'neuroglancer-link'
    const linkElements = document.querySelectorAll(".neuroglancer-link");
    linkElements.forEach((element) => {
      element.href = neuroglancerUrl;
    });

    // Update all elements with class 'neuroglancer-iframe'
    const iframeElements = document.querySelectorAll(".neuroglancer-iframe");
    iframeElements.forEach((element) => {
      element.src = neuroglancerUrl;
    });
  } catch (error) {
    console.error("Error updating neuroglancer links:", error);
  }
}

/* ────────────────────────────────────────────────────────────────────────── */
/* Initialization                                                             */
/* ────────────────────────────────────────────────────────────────────────── */
/** Initializes neuroglancer links when the DOM is ready
 * This function should be called with the page data
 *
 * @param {Object} pageData - The page data containing neuroglancer parameters
 * @param {string} pageData.websiteTitle - The title for the neuroglancer session
 * @param {string[]} pageData.visibleNeurons - Array of neuron bodyIDs to display
 * @param {string} pageData.neuronQuery - Query string for neuron search
 * @param {string[]} pageData.visibleRois - Array of ROIs to display
 * @param {string[]} pageData.region - Region the type belongs to. Used for setting NG view.
 */
function initializeNeuroglancerLinks(pageData) {
  const run = () => {
    // Initialize ROI contexts and sync selectedRoiIds with pageData.visibleRois
    if (pageData.visibleRois && Array.isArray(pageData.visibleRois)) {
      // Clear existing data
      selectedRoiIds.clear();
      selectedRoiContexts.clear();

      // Add existing ROI IDs to selectedRoiIds and initialize contexts
      pageData.visibleRois.forEach(roiId => selectedRoiIds.add(String(roiId)));
      initializeRoiContexts(pageData.visibleRois.map(String));
    }

    const input = document.getElementById("nv-theme-toggle");
    const saved = localStorage.getItem("nvTheme");
    const initialTheme = saved || (input && input.checked ? "light" : "dark");

    currentNgTheme = initialTheme;
    currentProjectionBg = BG_BY_THEME[initialTheme] || BG_BY_THEME.dark;
    if (input) input.checked = initialTheme === "light";

    updateNeuroglancerLinks(
      pageData.websiteTitle,
      pageData.visibleNeurons,
      pageData.neuronQuery,
      pageData.visibleRois,
      pageData.region,
      currentProjectionBg,
    );
    wireRoiClicks(pageData);
    wireConnectivityCheckboxes(pageData);
    syncConnectivityCheckboxes(pageData);
    wireRoiCheckboxes(pageData);
    syncRoiCheckboxes();

    if (input) {
      input.addEventListener("change", () => {
        currentNgTheme = input.checked ? "light" : "dark";
        currentProjectionBg = BG_BY_THEME[currentNgTheme];
        localStorage.setItem("nvTheme", currentNgTheme);

        updateNeuroglancerLinks(
          pageData.websiteTitle,
          pageData.visibleNeurons,
          pageData.neuronQuery,
          pageData.visibleRois,
          pageData.region,
          currentProjectionBg,
        );
      });
    }
  };
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", run);
  } else {
    run();
  }
}

// Export functions if using modules
if (typeof module !== "undefined" && module.exports) {
  module.exports = {
    generateNeuroglancerUrl,
    updateNeuroglancerLinks,
    initializeNeuroglancerLinks,
    wireRoiClicks,
    syncConnectivityCheckboxes,
    wireConnectivityCheckboxes,
    syncRoiCheckboxes,
    wireRoiCheckboxes,
    getAllConnectivityBodyIds,
    hasActiveConnectivityBodies,
  };
} else if (typeof window !== "undefined") {
  // Make functions globally available for browser use
  window.generateNeuroglancerUrl = generateNeuroglancerUrl;
  window.updateNeuroglancerLinks = updateNeuroglancerLinks;
  window.initializeNeuroglancerLinks = initializeNeuroglancerLinks;
  window.wireRoiClicks = wireRoiClicks;
  window.syncConnectivityCheckboxes = syncConnectivityCheckboxes;
  window.wireConnectivityCheckboxes = wireConnectivityCheckboxes;
  window.syncRoiCheckboxes = syncRoiCheckboxes;
  window.wireRoiCheckboxes = wireRoiCheckboxes;
  window.getAllConnectivityBodyIds = getAllConnectivityBodyIds;
  window.hasActiveConnectivityBodies = hasActiveConnectivityBodies;
  window.roiNameToId = roiNameToId;
  window.vncNameToId = vncNameToId;
}

// Simple ROI table layout fix on page load
function forceRoiTableLayout() {
  const roiTable = document.getElementById("roi-table");
  if (!roiTable) return;

  roiTable.style.tableLayout = "fixed";
  const firstColumnCells = roiTable.querySelectorAll("tbody td:first-child");
  firstColumnCells.forEach((cell) => {
    cell.style.width = "250px";
    cell.style.maxWidth = "250px";
  });
}

// Enhanced page load initialization
function initializePage() {
  forceRoiTableLayout();
  console.log("[PAGE INIT] ROI contexts initialized:", selectedRoiContexts.size, "entries");
}

// Run on page load
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initializePage);
} else {
  initializePage();
}
{% endraw %}
