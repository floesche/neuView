<svg width="{{ width }}" height="{{ height }}" xmlns="http://www.w3.org/2000/svg">
<defs>
<style>
.hex-tooltip { font-family: Arial, sans-serif; font-size: 12px; }
.tooltip-box { pointer-events: none; transition: opacity 0.2s; z-index: 9999; }
.tooltip-rect { fill: rgba(0, 0, 0, 0.8); rx: 3; ry: 3; }
.tooltip-text { fill: white; font-family: Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif; font-size: 14px; }
</style>
</defs>

<script type="text/javascript">
//<![CDATA[
function showTooltip(evt) {
    var tooltip = document.getElementById("tooltip");
    var titleElement = evt.target.querySelector("title");
    if (!titleElement) return;
    var text = titleElement.textContent;
    if (!text) return;

    evt.target.setAttribute("data-original-title", text);

    var lines = text.split("\n");

    titleElement.textContent = "";
    var maxWidth = 0;
    var lineHeight = 14;
    var padding = 6;

    var textGroup = document.getElementById("tooltip-text-group");
    while (textGroup.firstChild) {
        textGroup.removeChild(textGroup.firstChild);
    }

    for (var i = 0; i < lines.length; i++) {
        if (lines[i].trim() === "") continue;
        var textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textElement.setAttribute("x", padding);
        textElement.setAttribute("y", padding + lineHeight + (i * lineHeight));
        textElement.setAttribute("class", "tooltip-text");
        textElement.textContent = lines[i];
        textGroup.appendChild(textElement);

        var textWidth = lines[i].length * 6.5;
        if (textWidth > maxWidth) maxWidth = textWidth;
    }

    var rect = document.getElementById("tooltip-rect");
    var boxWidth = Math.max(maxWidth + padding * 2, 100);
    var boxHeight = lines.length * lineHeight + padding * 2;
    rect.setAttribute("width", boxWidth);
    rect.setAttribute("height", boxHeight);

    var svgRect = evt.currentTarget.ownerSVGElement.getBoundingClientRect();
    var x = evt.clientX - svgRect.left + 10;
    var y = evt.clientY - svgRect.top - boxHeight - 10;

    if (x + boxWidth > {{ width }}) x = {{ width }} - boxWidth - 5;
    if (y < 0) y = evt.clientY - svgRect.top + 10;
    if (x < 0) x = 5;

    tooltip.setAttribute("transform", "translate(" + x + "," + y + ")");
    tooltip.setAttribute("opacity", "1");
}

function hideTooltip() {
    var tooltip = document.getElementById("tooltip");
    if (tooltip) {
        tooltip.setAttribute("opacity", "0");
    }
}

function restoreTitle(evt) {
    var originalTitle = evt.target.getAttribute("data-original-title");
    if (originalTitle) {
        var titleElement = evt.target.querySelector("title");
        if (titleElement) {
            titleElement.textContent = originalTitle;
        }
        evt.target.removeAttribute("data-original-title");
    }
}

function updateHexColors(layer) {
    document.getElementById("layerValue").textContent = layer;

    var hexes = document.querySelectorAll(".hex-path");
    hexes.forEach(function(hex) {
        var colors = hex.getAttribute("data-layer-colors");
        if (!colors) return;

        try {
            var colorMap = JSON.parse(colors);
            var color = colorMap[layer];
            if (color) {
                hex.setAttribute("fill", color);
            } else {
                hex.setAttribute("fill", "#cccccc"); // fallback
            }
        } catch (e) {
            console.error("Error parsing layer colors", e);
        }
    });
}

// NEW FUNCTION: find min/max layer keys and set scrollbar
function initializeLayerScrollbar() {
    var hexes = document.querySelectorAll(".hex-path");
    var allLayers = [];

    hexes.forEach(function(hex) {
        var colors = hex.getAttribute("data-layer-colors");
        if (!colors) return;

        try {
            var colorMap = JSON.parse(colors);
            var keys = Object.keys(colorMap).map(Number);
            allLayers = allLayers.concat(keys);
        } catch (e) {
            console.error("Error parsing layer colors", e);
        }
    });

    if (allLayers.length === 0) return;

    var minLayer = Math.min.apply(null, allLayers);
    var maxLayer = Math.max.apply(null, allLayers);

    var slider = document.getElementById("layerScrollbar");
    slider.min = minLayer;
    slider.max = maxLayer;
    slider.step = 1;
    slider.value = minLayer;

    document.getElementById("layerValue").textContent = minLayer;

    // Initialize colors with min layer
    updateHexColors(minLayer);
}

// Run after DOM loads
document.addEventListener("DOMContentLoaded", initializeLayerScrollbar);
//]]>
</script>

<!-- Background -->
<rect width="{{ width }}" height="{{ height }}" fill="#f8f9fa" stroke="none"/>


<!-- Title, Subtitle, and Layer Scrollbar -->
<text x="5" y="15" text-anchor="start" font-family="Arial, sans-serif" font-size="12" fill="#CCCCCC">{{ title }}</text>
<text x="5" y="28" text-anchor="start" font-family="Arial, sans-serif" font-size="10" fill="#CCCCCC">{{ subtitle }}</text>

<!-- Layer Scrollbar UI -->
<foreignObject x="220" y="10" width="220" height="40">
  <div xmlns="http://www.w3.org/1999/xhtml" style="font-size:14px; background:rgba(255,255,255,0.7); border-radius:6px; padding:4px;">
    <label for="layerScrollbar">Layer: </label>
    <input type="range" id="layerScrollbar"
           style="width:120px; vertical-align:middle;"
           oninput="updateHexColors(this.value)">
    <span id="layerValue"></span>
  </div>
</foreignObject>

<!-- Hexagon Path Definition -->
{% set hex_path = "M" + hex_points|join(" L") + " Z" %}

<!-- Hexagons -->
{% for hex_data in hexagons %}
{% set x = (hex_data.x - min_x + margin) | round(number_precision) %}
{% set y = (hex_data.y - min_y + margin) | round(number_precision) %}
<g transform="translate({{ x }},{{ y }})">
<path d="{{ hex_path }}"
      class="hex-path"
      fill="{{ hex_data.color }}"
      data-layer-colors='{{ hex_data.layer_colors | tojson }}'
      stroke="none"
      opacity="0.8"
      style="cursor: pointer;"
      onmouseover="showTooltip(evt)"
      onmouseout="hideTooltip(); restoreTitle(evt);">
<title>{{ hex_data.tooltip }}</title>
</path>
</g>
{% endfor %}

<!-- Legend (only if there's actual data) -->
{% if data_hexagons %}
<text x="{{ title_x }}" y="{{ title_y }}" ont-family="Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif"  font-size="8" font-weight="bold" text-anchor="middle" transform="rotate(-90 {{ title_x }} {{ title_y }})">{{ legend_title }}</text>

<!-- Color Legend Rectangles -->
{% for i, color in enumerate(colors) %}
{% set rect_y = legend_y + legend_height - (i + 1) * bin_height %}
<rect x="{{ legend_x }}" y="{{ rect_y }}" width="{{ legend_width }}" height="{{ bin_height }}" fill="{{ color }}" stroke="#999999" stroke-width="0.2" onmouseover="showTooltip(evt)" onmouseout="hideTooltip(); restoreTitle(evt);">
<title>{{ thresholds[i]|round(0)|int }}â€¦{{ thresholds[i+1]|round(0)|int }}</title>
</rect>
{% endfor %}

<!-- Threshold Labels -->
{% for i, threshold in enumerate(thresholds) %}
{% set label_y = legend_y + legend_height - i * bin_height %}
<text x="{{ legend_x - 3 }}" y="{{ label_y + 3 }}" font-family="Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif" text-anchor="end" font-size="10">{{ threshold|round(0)|int }}</text>
{% endfor %}
{% endif %}

<!-- Tooltip (rendered last to appear on top) -->
<g id="tooltip" class="tooltip-box" opacity="0">
  <rect id="tooltip-rect" class="tooltip-rect" width="100" height="40"/>
  <g id="tooltip-text-group"></g>
</g>

</svg>


