<svg width="470" height="480" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {{ width }} {{ height }}">
<defs>
<style>
.hex-tooltip { font-family: Arial, sans-serif; font-size: 12px; }
.tooltip-box { pointer-events: none; transition: opacity 0.2s; z-index: 9999; }
.tooltip-rect { fill: rgba(0, 0, 0, 0.8); rx: 3; ry: 3; }
.tooltip-text { fill: white; font-family: Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif; font-size: 14px; }

/* Layer control squares */
.layer-square { cursor: pointer; }
.layer-square.active { stroke: #333333; stroke-width: 2; }
.layer-square.inactive { stroke: #bbbbbb; stroke-width: 1; }
.layer-square-label { font-size: 9px; dominant-baseline: middle; text-anchor: middle; fill: #222; pointer-events: none; font-family: Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif;}
.layer-title { font-size: 12px; fill: #666; font-family: Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif;}
</style>
</defs>

<script type="text/javascript">
//<![CDATA[
function showTooltip(evt) {
    var tooltip = document.getElementById("tooltip");
    var titleElement = evt.target.querySelector("title");
    if (!titleElement) return;
    var text = titleElement.textContent;
    if (!text) return;

    evt.target.setAttribute("data-original-title", text);

    var lines = text.split("\n");

    titleElement.textContent = "";
    var maxWidth = 0;
    var lineHeight = 14;
    var padding = 6;

    var textGroup = document.getElementById("tooltip-text-group");
    while (textGroup.firstChild) {
        textGroup.removeChild(textGroup.firstChild);
    }

    for (var i = 0; i < lines.length; i++) {
        if (lines[i].trim() === "") continue;
        var textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textElement.setAttribute("x", padding);
        textElement.setAttribute("y", padding + lineHeight + (i * lineHeight));
        textElement.setAttribute("class", "tooltip-text");
        textElement.textContent = lines[i];
        textGroup.appendChild(textElement);

        var textWidth = lines[i].length * 6.5;
        if (textWidth > maxWidth) maxWidth = textWidth;
    }

    var rect = document.getElementById("tooltip-rect");
    var boxWidth = Math.max(maxWidth + padding * 2, 100);
    var boxHeight = lines.length * lineHeight + padding * 2;
    rect.setAttribute("width", boxWidth);
    rect.setAttribute("height", boxHeight);

    var svgRect = evt.currentTarget.ownerSVGElement.getBoundingClientRect();
    var x = evt.clientX - svgRect.left + 10;
    var y = evt.clientY - svgRect.top - boxHeight - 10;

    if (x + boxWidth > {{ width }}) x = {{ width }} - boxWidth - 5;
    if (y < 0) y = evt.clientY - svgRect.top + 10;
    if (x < 0) x = 5;

    tooltip.setAttribute("transform", "translate(" + x + "," + y + ")");
    tooltip.setAttribute("opacity", "1");
}

function hideTooltip() {
    var tooltip = document.getElementById("tooltip");
    if (tooltip) {
        tooltip.setAttribute("opacity", "0");
    }
}

function restoreTitle(evt) {
    var originalTitle = evt.target.getAttribute("data-original-title");
    if (originalTitle) {
        var titleElement = evt.target.querySelector("title");
        if (titleElement) {
            titleElement.textContent = originalTitle;
        }
        evt.target.removeAttribute("data-original-title");
    }
}

/* Highlight the active layer square */
function setActiveLayerControl(regionId, layer) {
    var group = document.getElementById("layerControls-" + regionId);
    if (!group) return;
    var squares = group.querySelectorAll("rect.layer-square");
    squares.forEach(function(r) {
        if (parseInt(r.getAttribute("data-layer"), 10) === layer) {
            r.classList.remove("inactive");
            r.classList.add("active");
        } else {
            r.classList.remove("active");
            r.classList.add("inactive");
        }
    });

    var label = document.getElementById("layerLabel-" + regionId);
    if (label) {
        label.textContent = (layer === 0) ? "All layers" : ("Layer " + layer);
    }
}

/* ===== Legend threshold switching ===== */

function updateLegendThresholds(layer, regionId) {
    // Find the legend group for this region
    var legend = document.getElementById("legend-" + regionId);
    if (!legend) return;

    var baseThresholds = [];
    var layerThresholds = [];

    try {
        baseThresholds = JSON.parse(legend.getAttribute("data-base-thresholds") || "[]");
        layerThresholds = JSON.parse(legend.getAttribute("data-layer-thresholds") || "[]");
    } catch (e) {
        // malformed JSON; bail quietly
        return;
    }

    var thr;
    if (layer === 0) {
        thr = baseThresholds;                // default thresholds (length 6)
    } else {
        var idx = layer - 1;                 // 0..9
        thr = (layerThresholds[idx] || []);  // per-layer thresholds (length 6)
        if (!Array.isArray(thr) || thr.length === 0) {
            thr = baseThresholds;            // fallback
        }
    }

    // Update tick labels (6 ticks)
    for (var i = 0; i < 6; i++) {
        var t = document.getElementById("legend-label-" + i + "-" + regionId);
        if (t) t.textContent = Math.round(thr[i] || 0);
    }

    // Update rect titles (5 bins: [0..1], [1..2], ..., [4..5])
    for (var b = 0; b < 5; b++) {
        var rect = document.getElementById("legend-rect-" + b + "-" + regionId);
    }
}

/* Core: apply a layer to all hexes in a plot */
function updateLayer(layer, regionId) {
    layer = parseInt(layer, 10);
    var hexplot = document.getElementById("hexplot-" + regionId);
    var paths = hexplot ? hexplot.querySelectorAll("path") : [];

    paths.forEach(function(path) {
        var layerColors = path.getAttribute("layer-colors");
        if (!layerColors) return;
        var colors = JSON.parse(layerColors);

        var layerValuesAttr = path.getAttribute("layer-values");
        var values = layerValuesAttr ? JSON.parse(layerValuesAttr) : null;

        var defaultColor = path.getAttribute("default-fill") || path.getAttribute("fill") || "#ffffff";

        if (layer === 0) {
            // Layer 0 represents all layers, therefore use the default
            path.setAttribute("fill", defaultColor);
        } else {
            var idx = layer - 1; // 1..10 -> 0..9
            if (idx >= 0 && idx < colors.length) {
                var pass = true;
                if (Array.isArray(values) && idx < values.length) {
                    pass = values[idx] > 0;
                }
                if (pass) {
                    path.setAttribute("fill", colors[idx]);
                } else {
                    // If the column's default is dark grey, use that; otherwise white
                    path.setAttribute("fill", (defaultColor === "#999999") ? defaultColor : "#ffffff");
                }
            }
        }
    });

    // Switch legend thresholds for this region
    updateLegendThresholds(layer, regionId);

    // Update button highlight/label
    setActiveLayerControl(regionId, layer);
}

//]]>
</script>

<!-- Background -->
<rect width="{{ width + 40 }}" height="{{ height }}" fill="#f8f9fa" stroke="none"/>

<!-- Title, Subtitle, and Layer Scrollbar -->
<text x="5" y="15" text-anchor="start" font-family="Arial, sans-serif" font-size="12" fill="#CCCCCC">{{ title }}</text>
<text x="5" y="28" text-anchor="start" font-family="Arial, sans-serif" font-size="10" fill="#CCCCCC">{{ subtitle }}</text>

<!-- Hexagon Path Definition -->
{% set hex_path = "M" + hex_points|join(" L") + " Z" %}

<!-- Layer buttons -->
{% set control_x = 3 %}
{% set square = 13 %}
{% set gap = 4 %}

{% if hexagons[0].region == 'ME' %}
{% set n_layers = 10 %}
{% set control_y0 = 210 %}
{% elif hexagons[0].region == 'LO' %}
{% set n_layers = 7 %}
{% set control_y0 = 210 + ((square + gap) * 3) %}
{% elif hexagons[0].region == 'LOP' %}
{% set n_layers = 4 %}
{% set control_y0 = 210 + ((square + gap) * 6) %}
{% else %}
{% set n_layers = 10 %}
{% set control_y0 = 210 %}
{% endif %}

<g id="layerControls-{{ hexagons[0].region }}">

  <!-- Row 0: "All" -->
  <g transform="translate({{ control_x }}, {{ control_y0 }})" onclick="updateLayer(0, '{{ hexagons[0].region }}')">
    <rect width="{{ square }}" height="{{ square }}" rx="2" ry="2"
          class="layer-square active" data-layer="0" fill="#ffffff"/>
    <text x="{{ square/2 }}" y="{{ square/2 }}" class="layer-square-label">A</text>
  </g>

  <!-- Rows 1..10 -->
  {% for i in range(1, n_layers+1) %}
  <g transform="translate({{ control_x }}, {{ control_y0 + (square + gap) * i }})"
     onclick="updateLayer({{ i }}, '{{ hexagons[0].region }}')">
    <rect width="{{ square }}" height="{{ square }}" rx="2" ry="2"
          class="layer-square inactive" data-layer="{{ i }}" fill="#ffffff"/>
    <text x="{{ square/2 }}" y="{{ square/2 }}" class="layer-square-label">{{ i }}</text>
  </g>
  {% endfor %}

  <!-- Current selection label -->
  <text id="layerLabel-{{ hexagons[0].region }}" x="{{ control_x + square + 6 }}"
        y="{{ control_y0 + (square + gap) * (n_layers + 0.5) }}" font-family="Arial, sans-serif" font-size="12" fill="#666666">
    All layers
  </text>
</g>

<!-- Hexagons -->
<g id="hexplot-{{ hexagons[0].region }}">
{% for hex_data in hexagons %}
{% set x = (hex_data.x - min_x + margin) | round(number_precision) %}
{% set y = (hex_data.y - min_y + margin) | round(number_precision) %}
<g transform="translate({{ x + 10 }},{{ y }})">
<path d="{{ hex_path }}"
      fill="{{ hex_data.color }}"
      default-fill="{{ hex_data.color }}"
      layer-colors='{{ hex_data.layer_colors | tojson }}'
      layer-values='{{ hex_data.layer_values | tojson }}'
      stroke="none"
      opacity="0.8"
      style="cursor: pointer;"
      onmouseover="showTooltip(evt)"
      onmouseout="hideTooltip(); restoreTitle(evt);">
<title>{{ hex_data.tooltip }}</title>
</path>
</g>
{% endfor %}
</g>

<!-- Legend (only if there's actual data) -->
{% if data_hexagons %}
    <!-- We store both threshold sets on the legend group as JSON -->
    <g id="legend-{{ hexagons[0].region }}"
        data-base-thresholds='{{ thresholds | tojson }}'
        data-layer-thresholds='{{ layer_thresholds | tojson }}'>
        <text x="{{ title_x }}" y="{{ title_y + 32 }}"
            font-family="Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif"
            font-size="8" font-weight="bold" text-anchor="middle"
            transform="rotate(-90 {{ title_x }} {{ title_y }})">{{ legend_title }}</text>

        <!-- Color Legend Rectangles (5 bins) -->
        {% for i, color in enumerate(colors) %}
        {% set rect_y = legend_y + legend_height - (i + 1) * bin_height %}
        <rect id="legend-rect-{{ i }}-{{ hexagons[0].region }}"
                x="{{ legend_x + 38 }}" y="{{ rect_y }}"
                width="{{ legend_width }}" height="{{ bin_height }}"
                fill="{{ color }}" stroke="#999999" stroke-width="0.2"
                onmouseover="showTooltip(evt)" onmouseout="hideTooltip(); restoreTitle(evt);">
            <!-- Initial title from default thresholds -->
            <title>{{ thresholds[i]|round(0)|int }}â€¦{{ thresholds[i+1]|round(0)|int }}</title>
        </rect>
        {% endfor %}

        <!-- Threshold Labels (6 ticks) -->
        {% for i, threshold in enumerate(thresholds) %}
        {% set label_y = legend_y + legend_height - i * bin_height %}
        <text id="legend-label-{{ i }}-{{ hexagons[0].region }}"
                x="{{ legend_x - 3 + 38}}" y="{{ label_y + 3 }}"
                font-family="Helvetica, Arial, 'Liberation Sans', 'Nimbus Sans', 'DejaVu Sans', sans-serif"
                text-anchor="end" font-size="10">{{ threshold|round(0)|int }}</text>
        {% endfor %}
    </g>
{% endif %}

<!-- Tooltip (rendered last to appear on top) -->
<g id="tooltip" class="tooltip-box" opacity="0">
  <rect id="tooltip-rect" class="tooltip-rect" width="100" height="40"/>
  <g id="tooltip-text-group"></g>
</g>

</svg>